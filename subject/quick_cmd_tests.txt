Conf Tests:

-> Error Page
On .conf, in server block, keyword: error_page

-> Try File
On .conf, in location block, keyword: try_file

-> Redirect
On .conf, in location block, keyword: return

-> Files on directory
On .conf, in location block, keyword: autoindex

--------------------------------------------------------------------------

Request Tests:

-> Simple Request ==> RESOLVIDO
curl --resolve localhost:8080:127.0.0.1 localhost:8080

-> Client Max Request Size ==> RESOLVIDO 2server.conf
Change client_max_body_size to 10 in .conf
curl -X POST -H "Content-Type: plain/text" --data "1234567890" localhost:8081/curl_post.py

-> Get Request ==> RESOLVIDO
curl localhost:8080/index.html

-> Post Request ==> RESOLVIDO
curl -X POST -H "Content-Type: plain/text" --data "1234567890" localhost:8080/curl_post.py

-> Download File
curl -O localhost:8080/upload/upload.txt

-> Delete Request
curl -X DELETE localhost:8080/upload/upload.txt

-> Unknown Request ==> RESOLVIDO
curl -X UNKNOWN localhost:8080

-> Same host port ==> RESOLVIDO (acho ?)
curl --resolve localhost:8080:127.0.0.1 localhost:8080 # default server
curl --resolve black:8080:127.0.0.1 black:8080 # other server
curl --resolve gold:8080:127.0.0.1 gold:8080 -o response.html && xdg-open response.html

--------------------------------------------------------------------------

Performance Tests:

-> Siege ==> RESOLVIDO
siege -b http://testing:8080/empty.html -t 1m
siege -b http://localhost:8080/empty.html -t10s
siege -b http://localhost:8080/index.html -t1m


-> Leaks
pgrep webserv
top -p <process ID>

-> Hanging Out durinh siege ==> RESOLVIDO ?? (penso que faz o que 'e suposto)
watch -n 1 netstat -tuln

-> para fazer upload de um ficheiro para o servidor
curl -T upload.txt localhost:8080/resources/upload/

--------------------------------------------------------------------------------
FRED

-> To see a POST with a very big body request ==> RESOLVIDO
yes "Our group FFB is the Best!!!" | head -n 1000000 > largefile.txt  ou make large
curl -X POST -H "Content-Type: text/plain" --data-binary @largefile.txt http://localhost:8080/your_endpoint
(para ver os bytes)  wc -c largefile.txt
(para ver os megabytes)  du -h largefile.txt
curl -X POST -H "Content-Type: text/plain" -T largefile.txt http://localhost:8080/your_endpoint     -> serve para enviar arquivo como fluxo de dados

curl -X POST -H "Content-Type: text/plain" -T subject/webserver.pdf http://localhost:8080/your_endpoint --output response.bin


-> dd if=/dev/zero of=file.txt bs=1 count=10485860

curl -I http://127.0.0.1:8082/redirect
curl -L http://127.0.0.1:8082/redirect

Evaluation Page
curl -X POST -H "Content-Type: text/plain" --data "BODY IS HERE write something shorter or longer than body limit" http://localhost:8080/your-endpoint


=> verificar pasta do upload e delete e so tem ai a permissao






No servidor Nginx, o código de status HTTP retornado após uma solicitação DELETE depende do resultado da operação. Aqui estão alguns possíveis códigos de status:

- `200 OK`: A solicitação DELETE foi bem-sucedida e o recurso foi removido.
- `202 Accepted`: A solicitação foi aceita para processamento, mas o processamento ainda não foi concluído.
- `204 No Content`: A solicitação DELETE foi bem-sucedida, mas não há representação para incluir no corpo da resposta (por exemplo, o recurso foi removido).
- `400 Bad Request`: A solicitação não pôde ser entendida ou estava faltando parâmetros necessários.
- `401 Unauthorized`: A autenticação é necessária para acessar o recurso.
- `403 Forbidden`: O servidor entendeu a solicitação, mas se recusa a autorizá-la.
- `404 Not Found`: O recurso que você estava tentando alcançar não pôde ser encontrado no servidor.
- `405 Method Not Allowed`: O método DELETE não é permitido para o recurso solicitado.
- `500 Internal Server Error`: Um erro ocorreu no servidor.

Por favor, note que esses são apenas alguns dos possíveis códigos de status HTTP que podem ser retornados. O código de status exato dependerá da implementação específica do servidor e do resultado da operação DELETE.


mudar caminho da root manual de resorses para o caminho vindo da perser da filipa
Postman



Quando o Nginx encontra múltiplos blocos `server` com a mesma diretiva `listen`
(ou seja, ouvindo na mesma porta), ele usa a diretiva `server_name` para diferenciar as
requisições e determinar qual bloco `server` deve ser usado para tratar a requisição.
O procedimento é o seguinte:

1. **Análise da Porta**: Nginx verifica a porta na qual a requisição foi recebida. No caso,
ambas as configurações estão ouvindo na porta `8080`.

2. **Seleção do Server Name**: Nginx olha para o cabeçalho `Host` da requisição HTTP para
determinar o `server_name` correspondente. Se o valor do cabeçalho `Host` corresponder ao
`server_name` de um dos blocos `server`, esse bloco será usado para processar a requisição.

    - Se a requisição vier com o cabeçalho `Host` definido como `example.com`, o bloco
      `server` com `server_name maria` será selecionado.
    - Se a requisição vier com o cabeçalho `Host` definido como `localhost`, o bloco
      `server` com `server_name fred` será selecionado.

3. **Processamento da Requisição**: Uma vez selecionado o bloco `server` correto, Nginx
processa a requisição de acordo com as diretivas definidas dentro desse bloco.

4. **Caso de Falha na Correspondência**: Se nenhuma correspondência for encontrada
(por exemplo, se o cabeçalho `Host` da requisição não corresponder a nenhum `server_name`
configurado), Nginx usará o primeiro bloco `server` para a porta especificada como padrão.

5. **Diretivas Específicas**: Dentro de cada bloco `server`, as diretivas definem como
tratar diferentes caminhos de URL (`location`), como lidar com erros (`error_page`),
limitações de tamanho de corpo de requisição (`client_body_size`), entre outras configurações.

Portanto, a primeira etapa na determinação de qual bloco `server` será usado é baseada
na combinação da porta e do `server_name` através do cabeçalho `Host` da requisição.
Isso permite que múltiplos sites sejam hospedados no mesmo servidor físico, diferenciando-os
por nome de domínio ou subdomínio.